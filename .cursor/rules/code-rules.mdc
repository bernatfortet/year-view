---
description:
globs:
alwaysApply: true
---

Approach:

- Whenever doing anything that's not small, think carefully and ask any question you have to clarify.
- Be very careful with what you touch, I don't want you to remove functionality that was already there unless it's ncessary, so do a double check to make sure.

Proactively Avoiding issues

- As much as you can, you will think about where a code flow might break if the data is undefined. E.g. obj = { A: 'a' } and then we have code that checks obj.b. This will break the app. We need to do obj?.b. Ideally you use the `?` operator as much as possible to keep code clean.

Answer style

- I want answers to be very concise and to the point.
- If I start a prompt with "short" only give me the snippet. Only code. No sentences.

Naming

- never abbreviate. E.g. a param of type DataSource. should be `dataSource`, instead of `ds`. it's ok to shorten the naming but should never be cryptic. E.g. dynamicDataResolver.map(resolver => ... )

Function style

- I like files to have functions ordered by entry method at the top. Eg. the most atomic logic lives at the very bottom.
- I like to use small function that do very specific jobs.
- I don't like default exports
- I like to use functions instead of `const myFunc = () => { ... }`
- I like functions to use object params instead of inline params. Any function with more than 2 params, should use an object. E.g. myFunc(params: { param1: string, param2: boolean, param3: number})
- then I like to destructure the params on the next line.
- VERY IMPORTANT! "I always want function to be from higher level (top of file) to lower lavel/atomic (bottom of file)". E.g. if a function calls another function I'll want the called function below the caller.
- neve return the results of functions. Instead assign the fn return to a const, and then return it. that helps a lot with debugging. e.g. `const res = fn()`, then `return res`

### Function Extraction Guidelines

**When to extract a function into its own helper:**

1. **Size threshold**: Extract when a code block exceeds ~30-40 lines within a function. This includes:
   - Loops with complex logic (especially async operations)
   - Multiple sequential async operations (file reads, API calls, transformations)
   - Large conditional blocks with nested logic
   - Data transformation pipelines (extract ‚Üí transform ‚Üí validate ‚Üí structure)

2. **Natural helper patterns** (always extract these):
   - **I/O operations**: File reads/writes, IndexedDB operations, API calls
   - **Pure transformations**: Data mapping, formatting, validation
   - **Side-effect handlers**: Evidence cleanup, subscription management, blob URL management
   - **Repeated patterns**: Logic that appears similar but with different inputs/outputs

3. **Complexity indicators** (extract if you see):
   - Multiple levels of nesting (3+ levels deep)
   - Multiple try-catch blocks
   - Complex error handling with multiple error types
   - Loops that do more than simple iteration (contain async ops, transformations, or conditional logic)

4. **Single Responsibility**: If a function does more than one distinct thing, extract each "thing" into its own function.

**Function naming for extracted helpers:**

- Use descriptive verb phrases: `addBlobUrlsToOptimisticEntity`, `createAttachmentDescriptors`, `revokeBlobUrls`
- Avoid generic names like `helper`, `util`, `process` - be specific about what the function does

**Example pattern:**

```ts
// ‚ùå BAD: Large inline block
async function createOptimisticEntity(params) {
  // ... setup code ...

  // 50+ lines of attachment processing here
  const attachmentsDescriptor = await extractAttachmentsDescriptors(...)
  for (const descriptor of attachmentsDescriptor) {
    const file = await readQueuedFile({ id: descriptor.fileId })
    const blobUrl = URL.createObjectURL(file)
    const attachment = { url: blobUrl, ... }
    entity.meta[descriptor.fieldName] = attachment
    // ... more logic ...
  }

  return entity
}

// ‚úÖ GOOD: Extracted helper
async function createOptimisticEntity(params) {
  // ... setup code ...

  const { blobUrls, attachmentsDescriptor, updatedEntity } = await addBlobUrlsToOptimisticEntity({
    formData: params.formData,
    entity: finalOptimisticEntity,
    entityConfig: params.entityConfig,
  })

  return updatedEntity
}

// Helper placed below caller
async function addBlobUrlsToOptimisticEntity(params) {
  // ... 50+ lines of attachment processing ...
}
```

Types:

- types that are only used in a funciton should stay above that function.

Other style

- when using if, and there's only one line in ithat if, use a single line. e.g. `if(true) doSomething()` or `if(true) return`

### Early Returns (Guideline)

- Prefer early returns to reduce nesting and improve readability.
- Handle error/empty/loading cases first, then render the success path.
- Example:

```tsx
function Example({ items }: { items?: string[] }) {
  if (!items || items.length === 0) return <Empty />
  return <List items={items} />
}
```

Folder and files

- when setting up files in folders use dash case eg. "linkedin-parser"

Comments

- Don't over comment. If it seems right to comment, only do it if the surrounding code is not clear enough. We use typescript so functions already have a lot of context. Commenting complex logic is fine. Althought it's best to apply clean code principels and modularize the complexity
- Never add comments that don't add context or clarity. E.g. when the comment essentially says the same as a function name

Error Handling

- use ts-result-custom and ts-result and result-serializable (for server to client sending of results) to handle errors
- ts-result-custom is a wrapper that automatically uses logger.error, so no need to be redundant whenver using Err(...)
- when using ts-result-custom inline the error like if(res.err) return Err(..)

Logging

- When logging/printing, always show a string to contextualize what's being logged. e.g. console.log('foo', foo) or print('foo', foo)
- When using logs I like to add an emoji. Some common ones: ‚úÖ for final logs, üåÄ when waiting for things to be loaded, üíæ When saving to db, disk, etc, ‚ùå or üóëÔ∏è when deleting, üö®for errors, üèÅ when staritng thihgs, no funny emojis, keep it very functional/descriptive.
- **Atomic Functions:** Log specific operation details, inputs, outputs, and internal success/failure.
- **Higher-Level Functions:** Log the overall process flow, context (e.g., relevant IDs), key parameters, branching decisions, and handle/log errors returned by called functions (adding context).
- **Avoid Redundancy:** Don't repeat logs already present in lower-level functions called within the chain. Focus on adding contextual value at each level.

### **Clean Code Principles**

- Code should be clear, readable, and easy to understand at a glance.
- Strive for simplicity by avoiding unnecessary complexity.
- Maintain consistency in naming, formatting, and structure across the project.
- **Write modular code**: Break down logic into small, reusable functions and components. Follow the Function Extraction Guidelines above - when a function exceeds ~30-40 lines or handles multiple concerns, extract helpers.
- Keep concerns separated by organizing logic, UI, and data handling distinctly.
- Prioritize maintainability by ensuring the code is easy to modify, extend, and debug.
- Design code to scale efficiently without over-engineering upfront.
- Implement robust error handling to prevent failures and unexpected behavior.
- Use structured logging with contextual information to aid debugging and monitoring.
- Ensure code behaves predictably and remains stable under various conditions.

When asked to "apply clean code" deeply reflect on the above clean code principles and then activate planner mode (see below) to propose changes.

### UI

Never repeat the same type of ui element twice. that is, if a list of elements (e.g. nav bar) will have similar props, and same styles. Just create a component out of it. you can use [classed.ts](mdc:src/styles/classed.ts) for just styling, or a fn component at the bottom of the file that takes props.

### Testing Workflow

- **CRITICAL: Always use `bun run test` NOT `bun test`**
  - `bun run test` ‚Üí Runs vitest (respects vitest.config.ts, setupFiles, mocks, server-only aliases)
  - `bun test` ‚Üí Runs Bun's built-in test runner (doesn't respect vitest config, will fail on server-only imports)
- **Auto-detect test files**: Before modifying any file, check if a corresponding test file exists (e.g., `src/utils/foo.ts` ‚Üí `src/utils/__tests__/foo.test.ts`)
- **Test-driven changes**: When a test file exists, follow this workflow:
  1. Run tests BEFORE making changes: `bun run test path/to/test.file.ts`
  2. Make your edits to the source file
  3. Run tests AFTER changes: `bun run test path/to/test.file.ts`
  4. Ensure all tests pass before considering the task complete
- **Test file headers**: Include testing workflow instructions in file headers for critical utilities
- **Test coverage**: When creating new utility functions, create comprehensive test files covering edge cases, error handling, and expected behavior

### File Organization & Imports

- **No barrel exports**: Never create `index.ts` files for re-exporting. Use direct imports from specific files instead.
- **IDE auto-import**: Rely on IDE/AI auto-import capabilities rather than manual import management through barrel files.
- **Direct file imports**: Import directly from the source file: `import { Component } from './specific-file'` not `import { Component } from './folder'`

### Vertical Spacing (Readability)

- **One blank line between logical blocks**:
  - After import groups, constant/variable declarations, permission/guard checks, loops/conditionals, I/O (FS/network/DB) calls, and before the final return.
- **Early returns**: keep a blank line after each guard return before the ‚Äúhappy path‚Äù.
- **Group related lines**: declarations together, transformations together, side-effects together; separate each group with one blank line.
- **No extra vertical noise**:
  - Never use more than one consecutive blank line.
  - No blank line immediately after `{` or immediately before `}`.
- **Small functions (<6 lines)**: blank lines are optional; prefer clarity over density.
- **Function order**: higher-level first, helpers below; keep a blank line between function definitions.

Example (preferred):

```ts

```

### Working with the database

- We don't use migrations, and we don't have a dev/staging database. All changes happen in production. This is intentional
- This means that when we work with the DB we need to:

1. ALWAYS make sure that we're not deleting columns first. We add columns redirect code there. Test in production. Then delete columns. PLEASE make sure sure to warn me of this. I might forget.
2. Always triple check with me whenever suggesting schema changes. I need to be careful. e.g. Doing change at night or weekend and making sure I have time to follow through and tests
